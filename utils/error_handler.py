"""
üö® Universal DOE Platform - ÏóêÎü¨ Ìï∏Îì§Îü¨
================================================================================
error_config.pyÏùò ÏÑ§Ï†ïÏùÑ Í∏∞Î∞òÏúºÎ°ú Ïã§Ï†ú ÏóêÎü¨ Ï≤òÎ¶¨Î•º ÏàòÌñâÌïòÎäî Ìï∏Îì§Îü¨
ÏûêÎèô Î≥µÍµ¨, ÏÇ¨Ïö©Ïûê ÏïåÎ¶º, Î°úÍπÖ Îì±ÏùÑ ÌÜµÌï© Í¥ÄÎ¶¨
================================================================================
"""

import streamlit as st
import logging
import traceback
import time
from typing import Optional, Dict, Any, List, Callable, Union
from datetime import datetime
from contextlib import contextmanager
from functools import wraps
import json
import sys
from pathlib import Path

# error_config ÏûÑÌè¨Ìä∏
try:
    from config.error_config import (
        ErrorDefinition, ErrorCategory, ErrorSeverity, RecoveryStrategy,
        ERROR_CODES, ERROR_SEVERITY_CONFIG, RECOVERY_CONFIG,
        ERROR_MESSAGE_TEMPLATES, ERROR_RECOVERY_STRATEGIES,
        get_error_definition, format_error_message, should_auto_recover,
        get_recovery_actions, log_error, get_user_friendly_message,
        get_error_color, RECOVERY_ACTIONS
    )
except ImportError:
    # Í∞úÎ∞ú Ï§ë ÏûÑÌè¨Ìä∏ Ïò§Î•ò Ï≤òÎ¶¨
    print("Warning: error_config not found, using fallback")
    ERROR_CODES = {}
    ErrorSeverity = type('ErrorSeverity', (), {'ERROR': 'error'})

# ============================================================================
# üéØ ÏóêÎü¨ Ìï∏Îì§Îü¨ ÌÅ¥ÎûòÏä§
# ============================================================================

class ErrorHandler:
    """Ï§ëÏïôÏßëÏ§ëÏãù ÏóêÎü¨ Ï≤òÎ¶¨ Í¥ÄÎ¶¨Ïûê"""
    
    def __init__(self):
        """ÏóêÎü¨ Ìï∏Îì§Îü¨ Ï¥àÍ∏∞Ìôî"""
        self.error_history: List[Dict[str, Any]] = []
        self.recovery_attempts: Dict[str, int] = {}
        self.suppressed_errors: set = set()
        self.custom_handlers: Dict[str, Callable] = {}
        self.setup_logging()
        
    def setup_logging(self):
        """Î°úÍπÖ ÏÑ§Ï†ï"""
        log_dir = Path("./data/logs")
        log_dir.mkdir(parents=True, exist_ok=True)
        
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_dir / 'errors.log'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger('ErrorHandler')
    
    # ========================================================================
    # üîß ÏóêÎü¨ Ï≤òÎ¶¨ Î©îÏù∏ Î©îÏÑúÎìú
    # ========================================================================
    
    def handle_error(
        self,
        error_code: str,
        context: Dict[str, Any] = None,
        exception: Exception = None,
        show_notification: bool = True,
        auto_recover: bool = True
    ) -> bool:
        """
        ÏóêÎü¨ Ï≤òÎ¶¨ Î©îÏù∏ Ìï®Ïàò
        
        Args:
            error_code: ÏóêÎü¨ ÏΩîÎìú
            context: ÏóêÎü¨ Ïª®ÌÖçÏä§Ìä∏ Ï†ïÎ≥¥
            exception: Î∞úÏÉùÌïú ÏòàÏô∏ Í∞ùÏ≤¥
            show_notification: ÏÇ¨Ïö©Ïûê ÏïåÎ¶º ÌëúÏãú Ïó¨Î∂Ä
            auto_recover: ÏûêÎèô Î≥µÍµ¨ ÏãúÎèÑ Ïó¨Î∂Ä
            
        Returns:
            bool: ÏóêÎü¨ Ï≤òÎ¶¨ ÏÑ±Í≥µ Ïó¨Î∂Ä
        """
        context = context or {}
        
        # ÏóêÎü¨ Ï†ïÏùò Í∞ÄÏ†∏Ïò§Í∏∞
        error_def = get_error_definition(error_code)
        if not error_def:
            self.logger.error(f"Unknown error code: {error_code}")
            return False
        
        # ÏóêÎü¨ Í∏∞Î°ù
        self._record_error(error_code, context, exception)
        
        # Î°úÍπÖ
        log_error(error_code, context, exception)
        
        # ÏÇ¨Ïö©Ïûê ÏïåÎ¶º
        if show_notification and error_def.notify_user:
            self._show_notification(error_def, context)
        
        # ÏûêÎèô Î≥µÍµ¨ ÏãúÎèÑ
        if auto_recover and error_def.auto_recoverable:
            return self._attempt_recovery(error_def, context)
        
        # ÏàòÎèô Í∞úÏûÖ ÌïÑÏöî
        if error_def.recovery_strategy == RecoveryStrategy.USER_INTERVENTION:
            self._show_intervention_dialog(error_def, context)
        
        return not error_def.can_continue
    
    # ========================================================================
    # üîÑ ÏûêÎèô Î≥µÍµ¨ Î©îÏÑúÎìú
    # ========================================================================
    
    def _attempt_recovery(self, error_def: ErrorDefinition, context: Dict[str, Any]) -> bool:
        """ÏûêÎèô Î≥µÍµ¨ ÏãúÎèÑ"""
        error_code = error_def.code
        
        # Ïû¨ÏãúÎèÑ ÌöüÏàò ÌôïÏù∏
        attempt_key = f"{error_code}_{json.dumps(context, sort_keys=True)}"
        current_attempts = self.recovery_attempts.get(attempt_key, 0)
        
        if current_attempts >= error_def.max_retries:
            self.logger.warning(f"Max recovery attempts reached for {error_code}")
            return False
        
        self.recovery_attempts[attempt_key] = current_attempts + 1
        
        # Î≥µÍµ¨ Ïï°ÏÖò Ïã§Ìñâ
        recovery_actions = get_recovery_actions(error_code)
        if not recovery_actions:
            recovery_actions = error_def.recovery_actions
        
        for action in recovery_actions:
            try:
                if self._execute_recovery_action(action, context):
                    self.logger.info(f"Recovery successful for {error_code} using {action}")
                    self.recovery_attempts[attempt_key] = 0  # ÏÑ±Í≥µ Ïãú Î¶¨ÏÖã
                    return True
            except Exception as e:
                self.logger.error(f"Recovery action failed: {action} - {str(e)}")
                continue
        
        # Î≥µÍµ¨ Ï†ÑÎûµÎ≥Ñ Ï≤òÎ¶¨
        return self._apply_recovery_strategy(error_def, context)
    
    def _execute_recovery_action(self, action: Dict[str, Any], context: Dict[str, Any]) -> bool:
        """Î≥µÍµ¨ Ïï°ÏÖò Ïã§Ìñâ"""
        action_name = action.get('action')
        params = action.get('params')
        
        # ÎÇ¥Ïû• Î≥µÍµ¨ Ìï®ÏàòÎì§ ÏßÅÏ†ë Ïã§Ìñâ
        if action_name == 'clear_cache':
            return self._clear_cache_action(params, context)
        elif action_name == 'switch_to_offline':
            return self._switch_to_offline_action(params, context)
        elif action_name == 'manual_input_prompt':
            return self._show_manual_input(params, context)
        
        # Ïô∏Î∂Ä Î™®Îìà Ìï®Ïàò Ìò∏Ï∂ú
        action_info = RECOVERY_ACTIONS.get(action_name, {})
        function_path = action_info.get('function')
        
        if not function_path:
            self.logger.error(f"Unknown recovery action: {action_name}")
            return False
        
        try:
            # protocol_extractorÎÇò Îã§Î•∏ Î™®ÎìàÏùò Ìï®Ïàò Ìò∏Ï∂ú
            module_path, function_name = function_path.rsplit('.', 1)
            
            # Ïù¥ÎØ∏ Î°úÎìúÎêú Î™®Îìà ÌôïÏù∏ (ÏàúÌôò ÏûÑÌè¨Ìä∏ Î∞©ÏßÄ)
            if module_path == 'utils.protocol_extractor':
                from utils.protocol_extractor import (
                    try_multiple_encodings, detect_encoding, 
                    read_as_binary, enhance_image, try_multiple_ocr
                )
                func_map = {
                    'try_multiple_encodings': try_multiple_encodings,
                    'detect_encoding': detect_encoding,
                    'read_as_binary': read_as_binary,
                    'enhance_image': enhance_image,
                    'try_multiple_ocr': try_multiple_ocr
                }
                func = func_map.get(function_name)
            else:
                # Îã§Î•∏ Î™®ÎìàÏùÄ ÎèôÏ†Å ÏûÑÌè¨Ìä∏
                module = __import__(module_path, fromlist=[function_name])
                func = getattr(module, function_name)
            
            # ÌååÎùºÎØ∏ÌÑ∞ÏôÄ Ìï®Íªò Ìï®Ïàò Ìò∏Ï∂ú
            if params:
                result = func(*params, **context)
            else:
                result = func(**context)
            
            return bool(result)
            
        except Exception as e:
            self.logger.error(f"Failed to execute recovery action {action_name}: {str(e)}")
            return False
    
    def _clear_cache_action(self, params: Optional[List[str]], context: Dict[str, Any]) -> bool:
        """Ï∫êÏãú Ï†ïÎ¶¨ Ïï°ÏÖò"""
        try:
            cache_types = params or ['temp', 'api_responses']
            if 'cache' in st.session_state:
                for cache_type in cache_types:
                    if cache_type in st.session_state.cache:
                        st.session_state.cache[cache_type].clear()
            return True
        except Exception as e:
            self.logger.error(f"Cache clear failed: {str(e)}")
            return False
    
    def _switch_to_offline_action(self, params: Optional[List], context: Dict[str, Any]) -> bool:
        """Ïò§ÌîÑÎùºÏù∏ Î™®Îìú Ï†ÑÌôò Ïï°ÏÖò"""
        try:
            st.session_state['offline_mode'] = True
            st.session_state['offline_reason'] = context.get('error_code', 'network_error')
            return True
        except Exception as e:
            self.logger.error(f"Offline switch failed: {str(e)}")
            return False
    
    def _show_manual_input(self, params: Optional[List], context: Dict[str, Any]) -> bool:
        """ÏàòÎèô ÏûÖÎ†• Îã§Ïù¥ÏñºÎ°úÍ∑∏ ÌëúÏãú"""
        try:
            st.session_state['show_manual_input'] = True
            st.session_state['manual_input_context'] = context
            return True
        except Exception as e:
            self.logger.error(f"Manual input dialog failed: {str(e)}")
            return False
    
    def _apply_recovery_strategy(self, error_def: ErrorDefinition, context: Dict[str, Any]) -> bool:
        """Î≥µÍµ¨ Ï†ÑÎûµ Ï†ÅÏö©"""
        strategy = error_def.recovery_strategy
        config = RECOVERY_CONFIG.get(strategy, {})
        
        if strategy == RecoveryStrategy.RETRY:
            return self._retry_operation(error_def, context, config)
        elif strategy == RecoveryStrategy.FALLBACK:
            return self._use_fallback(error_def, context)
        elif strategy == RecoveryStrategy.CACHE:
            return self._use_cached_data(error_def, context)
        elif strategy == RecoveryStrategy.DEFAULT:
            return self._use_default_value(error_def, context)
        elif strategy == RecoveryStrategy.AUTO_FIX:
            return self._auto_fix(error_def, context)
        else:
            return False
    
    def _retry_operation(self, error_def: ErrorDefinition, context: Dict[str, Any], config: Dict) -> bool:
        """ÏûëÏóÖ Ïû¨ÏãúÎèÑ"""
        max_attempts = config.get('max_attempts', 3)
        delay = config.get('delay', error_def.retry_delay)
        backoff_factor = config.get('backoff_factor', 2.0)
        
        for attempt in range(max_attempts):
            if attempt > 0:
                wait_time = delay.total_seconds() * (backoff_factor ** (attempt - 1))
                time.sleep(wait_time)
            
            try:
                # ÏõêÎûò ÏûëÏóÖ Ïû¨Ïã§Ìñâ (contextÏóê Ï†ÄÏû•Îêú Ìï®Ïàò)
                original_func = context.get('_original_function')
                if original_func:
                    result = original_func(**context.get('_original_args', {}))
                    return True
            except Exception as e:
                self.logger.warning(f"Retry {attempt + 1}/{max_attempts} failed: {str(e)}")
                continue
        
        return False
    
    def _use_fallback(self, error_def: ErrorDefinition, context: Dict[str, Any]) -> bool:
        """ÎåÄÏ≤¥ Î∞©Î≤ï ÏÇ¨Ïö©"""
        fallback_func = context.get('_fallback_function')
        if fallback_func:
            try:
                fallback_func(**context.get('_fallback_args', {}))
                return True
            except Exception as e:
                self.logger.error(f"Fallback failed: {str(e)}")
        return False
    
    def _use_cached_data(self, error_def: ErrorDefinition, context: Dict[str, Any]) -> bool:
        """Ï∫êÏãúÎêú Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©"""
        cache_key = context.get('_cache_key')
        if cache_key and 'cache' in st.session_state:
            cached_value = st.session_state.cache.get(cache_key)
            if cached_value:
                context['_result'] = cached_value
                return True
        return False
    
    def _use_default_value(self, error_def: ErrorDefinition, context: Dict[str, Any]) -> bool:
        """Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©"""
        default_value = context.get('_default_value')
        if default_value is not None:
            context['_result'] = default_value
            return True
        return False
    
    def _auto_fix(self, error_def: ErrorDefinition, context: Dict[str, Any]) -> bool:
        """ÏûêÎèô ÏàòÏ†ï ÏãúÎèÑ"""
        # ÏóêÎü¨Î≥Ñ ÌäπÌôîÎêú ÏûêÎèô ÏàòÏ†ï Î°úÏßÅ
        if error_def.code == '4201':  # Ïù∏ÏΩîÎî© Ïò§Î•ò
            return self._fix_encoding(context)
        elif error_def.code == '4205':  # OCR Ïò§Î•ò
            return self._fix_ocr(context)
        return False
    
    def _fix_encoding(self, context: Dict[str, Any]) -> bool:
        """Ïù∏ÏΩîÎî© ÏûêÎèô ÏàòÏ†ï"""
        file_path = context.get('filename')
        if not file_path:
            return False
        
        encodings = ['utf-8', 'utf-8-sig', 'latin-1', 'cp1252', 'cp949', 'gbk']
        for encoding in encodings:
            try:
                with open(file_path, 'r', encoding=encoding) as f:
                    content = f.read()
                context['_result'] = content
                context['_fixed_encoding'] = encoding
                return True
            except:
                continue
        return False
    
    def _fix_ocr(self, context: Dict[str, Any]) -> bool:
        """OCR ÏûêÎèô Í∞úÏÑ†"""
        # Ïù¥ÎØ∏ÏßÄ Í∞úÏÑ† Î°úÏßÅ
        return False
    
    # ========================================================================
    # üîî ÏïåÎ¶º Î∞è UI Î©îÏÑúÎìú
    # ========================================================================
    
    def _show_notification(self, error_def: ErrorDefinition, context: Dict[str, Any]):
        """ÏÇ¨Ïö©Ïûê ÏïåÎ¶º ÌëúÏãú"""
        severity_config = ERROR_SEVERITY_CONFIG[error_def.severity]
        message = format_error_message(error_def.code, context)
        
        # Streamlit ÏïåÎ¶º ÌëúÏãú
        if error_def.severity == ErrorSeverity.CRITICAL:
            st.error(message, icon=severity_config['icon'])
        elif error_def.severity == ErrorSeverity.ERROR:
            st.error(message, icon=severity_config['icon'])
        elif error_def.severity == ErrorSeverity.WARNING:
            st.warning(message, icon=severity_config['icon'])
        elif error_def.severity == ErrorSeverity.INFO:
            st.info(message, icon=severity_config['icon'])
        
        # ÎèÑÏõÄÎßê ÎßÅÌÅ¨ Ï∂îÍ∞Ä
        if error_def.documentation_url:
            st.markdown(f"[üîó ÏûêÏÑ∏Ìïú ÎèÑÏõÄÎßê]({error_def.documentation_url})")
    
    def _show_intervention_dialog(self, error_def: ErrorDefinition, context: Dict[str, Any]):
        """ÏÇ¨Ïö©Ïûê Í∞úÏûÖ Îã§Ïù¥ÏñºÎ°úÍ∑∏"""
        with st.expander("üõ†Ô∏è Î¨∏Ï†ú Ìï¥Í≤∞ ÎèÑÏö∞ÎØ∏", expanded=True):
            st.write(f"**{error_def.name}**")
            st.write(error_def.user_message.format(**context))
            
            st.write("**Ìï¥Í≤∞ Î∞©Î≤ï:**")
            for i, suggestion in enumerate(error_def.recovery_suggestions, 1):
                st.write(f"{i}. {suggestion}")
            
            col1, col2 = st.columns(2)
            with col1:
                if st.button("Îã§Ïãú ÏãúÎèÑ", type="primary"):
                    st.session_state['retry_requested'] = True
                    st.rerun()
            with col2:
                if st.button("Í±¥ÎÑàÎõ∞Í∏∞"):
                    st.session_state['skip_error'] = True
    
    # ========================================================================
    # üìä ÏóêÎü¨ Í∏∞Î°ù Î∞è Î∂ÑÏÑù
    # ========================================================================
    
    def _record_error(self, error_code: str, context: Dict[str, Any], exception: Exception = None):
        """ÏóêÎü¨ Í∏∞Î°ù"""
        error_record = {
            'timestamp': datetime.now().isoformat(),
            'code': error_code,
            'context': context,
            'exception': str(exception) if exception else None,
            'traceback': traceback.format_exc() if exception else None,
            'session_id': st.session_state.get('session_id', 'unknown'),
            'user_id': st.session_state.get('user_id', 'anonymous')
        }
        
        self.error_history.append(error_record)
        
        # Î©îÎ™®Î¶¨ Í¥ÄÎ¶¨ (ÏµúÎåÄ 1000Í∞ú Ïú†ÏßÄ)
        if len(self.error_history) > 1000:
            self.error_history = self.error_history[-1000:]
    
    def get_error_statistics(self) -> Dict[str, Any]:
        """ÏóêÎü¨ ÌÜµÍ≥Ñ Î∞òÌôò"""
        if not self.error_history:
            return {}
        
        stats = {
            'total_errors': len(self.error_history),
            'by_category': {},
            'by_severity': {},
            'most_common': {},
            'recent_errors': self.error_history[-10:]
        }
        
        # Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ ÏßëÍ≥Ñ
        for record in self.error_history:
            error_def = get_error_definition(record['code'])
            if error_def:
                category = error_def.category.value
                severity = error_def.severity.value
                
                stats['by_category'][category] = stats['by_category'].get(category, 0) + 1
                stats['by_severity'][severity] = stats['by_severity'].get(severity, 0) + 1
                stats['most_common'][record['code']] = stats['most_common'].get(record['code'], 0) + 1
        
        # Í∞ÄÏû• ÎπàÎ≤àÌïú ÏóêÎü¨ Ï†ïÎ†¨
        stats['most_common'] = dict(sorted(
            stats['most_common'].items(),
            key=lambda x: x[1],
            reverse=True
        )[:5])
        
        return stats
    
    # ========================================================================
    # üé® Ïª®ÌÖçÏä§Ìä∏ Îß§ÎãàÏ†Ä Î∞è Îç∞ÏΩîÎ†àÏù¥ÌÑ∞
    # ========================================================================
    
    @contextmanager
    def error_context(self, operation_name: str, **kwargs):
        """ÏóêÎü¨ Ï≤òÎ¶¨ Ïª®ÌÖçÏä§Ìä∏ Îß§ÎãàÏ†Ä"""
        context = {
            'operation': operation_name,
            'start_time': datetime.now(),
            **kwargs
        }
        
        try:
            yield context
        except Exception as e:
            # ÏòàÏô∏ ÌÉÄÏûÖÏóê Îî∞Îùº ÏóêÎü¨ ÏΩîÎìú Îß§Ìïë
            error_code = self._map_exception_to_error_code(e, context)
            self.handle_error(error_code, context, e)
            
            # ÏóêÎü¨ Ï†ïÏùòÏóê Îî∞Îùº Ïû¨Î∞úÏÉù Ïó¨Î∂Ä Í≤∞Ï†ï
            error_def = get_error_definition(error_code)
            if error_def and not error_def.can_continue:
                raise
    
    def _map_exception_to_error_code(self, exception: Exception, context: Dict[str, Any]) -> str:
        """ÏòàÏô∏Î•º ÏóêÎü¨ ÏΩîÎìúÎ°ú Îß§Ìïë"""
        exception_type = type(exception).__name__
        exception_msg = str(exception).lower()
        
        # ÌååÏùº Í¥ÄÎ†® ÏòàÏô∏
        if isinstance(exception, FileNotFoundError):
            return '4001'
        elif isinstance(exception, PermissionError):
            return '1003'
        elif isinstance(exception, UnicodeDecodeError):
            return '4201'
        elif isinstance(exception, MemoryError):
            return '1001'
        elif isinstance(exception, ConnectionError):
            return '3001'
        elif isinstance(exception, TimeoutError):
            return '3002'
        
        # Î©îÏãúÏßÄ Í∏∞Î∞ò Îß§Ìïë
        if 'encoding' in exception_msg or 'decode' in exception_msg:
            return '4201'
        elif 'timeout' in exception_msg:
            return '4208'
        elif 'api' in exception_msg and 'key' in exception_msg:
            return '5001'
        elif 'rate limit' in exception_msg:
            return '5002'
        
        # Í∏∞Î≥∏Í∞í
        return '1000'  # ÏùºÎ∞ò ÏãúÏä§ÌÖú Ïò§Î•ò
    
    def error_handler(self, error_mappings: Dict[type, str] = None):
        """ÏóêÎü¨ Ï≤òÎ¶¨ Îç∞ÏΩîÎ†àÏù¥ÌÑ∞"""
        def decorator(func):
            @wraps(func)
            def wrapper(*args, **kwargs):
                operation_name = func.__name__
                context = {
                    'function': operation_name,
                    'args': args,
                    'kwargs': kwargs,
                    '_original_function': func,
                    '_original_args': kwargs
                }
                
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    # Ïª§Ïä§ÌÖÄ Îß§Ìïë ÌôïÏù∏
                    if error_mappings and type(e) in error_mappings:
                        error_code = error_mappings[type(e)]
                    else:
                        error_code = self._map_exception_to_error_code(e, context)
                    
                    # ÏóêÎü¨ Ï≤òÎ¶¨
                    handled = self.handle_error(error_code, context, e)
                    
                    # Ï≤òÎ¶¨ Í≤∞Í≥ºÏóê Îî∞Îùº ÌñâÎèô
                    error_def = get_error_definition(error_code)
                    if error_def and error_def.can_continue and handled:
                        # Í∏∞Î≥∏Í∞íÏù¥ÎÇò Î≥µÍµ¨Îêú Í∞í Î∞òÌôò
                        return context.get('_result', None)
                    else:
                        raise
            
            return wrapper
        return decorator
    
    # ========================================================================
    # üîß Ïú†Ìã∏Î¶¨Ìã∞ Î©îÏÑúÎìú
    # ========================================================================
    
    def register_custom_handler(self, error_code: str, handler: Callable):
        """Ïª§Ïä§ÌÖÄ ÏóêÎü¨ Ìï∏Îì§Îü¨ Îì±Î°ù"""
        self.custom_handlers[error_code] = handler
    
    def suppress_error(self, error_code: str):
        """ÌäπÏ†ï ÏóêÎü¨ ÏΩîÎìú ÏñµÏ†ú (ÏïåÎ¶º Ïïà Ìï®)"""
        self.suppressed_errors.add(error_code)
    
    def clear_error_history(self):
        """ÏóêÎü¨ Í∏∞Î°ù Ï¥àÍ∏∞Ìôî"""
        self.error_history.clear()
        self.recovery_attempts.clear()
    
    def export_error_report(self, filepath: str = None) -> str:
        """ÏóêÎü¨ Î¶¨Ìè¨Ìä∏ ÎÇ¥Î≥¥ÎÇ¥Í∏∞"""
        report = {
            'generated_at': datetime.now().isoformat(),
            'statistics': self.get_error_statistics(),
            'error_history': self.error_history[-100:],  # ÏµúÍ∑º 100Í∞ú
            'recovery_attempts': dict(self.recovery_attempts)
        }
        
        if filepath:
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(report, f, indent=2, ensure_ascii=False)
            return filepath
        else:
            return json.dumps(report, indent=2, ensure_ascii=False)


# ============================================================================
# üéØ Í∏ÄÎ°úÎ≤å ÏóêÎü¨ Ìï∏Îì§Îü¨ Ïù∏Ïä§ÌÑ¥Ïä§
# ============================================================================

# Ïã±Í∏ÄÌÜ§ Ìå®ÌÑ¥ÏúºÎ°ú Ï†ÑÏó≠ Ìï∏Îì§Îü¨ ÏÉùÏÑ±
_error_handler_instance = None

def get_error_handler() -> ErrorHandler:
    """Ï†ÑÏó≠ ÏóêÎü¨ Ìï∏Îì§Îü¨ Ïù∏Ïä§ÌÑ¥Ïä§ Î∞òÌôò"""
    global _error_handler_instance
    if _error_handler_instance is None:
        _error_handler_instance = ErrorHandler()
    return _error_handler_instance


# ============================================================================
# üõ†Ô∏è Ìé∏Ïùò Ìï®ÏàòÎì§
# ============================================================================

def handle_error(error_code: str, **kwargs) -> bool:
    """ÏóêÎü¨ Ï≤òÎ¶¨ Ìé∏Ïùò Ìï®Ïàò"""
    handler = get_error_handler()
    return handler.handle_error(error_code, **kwargs)


def with_error_handling(operation_name: str, **kwargs):
    """ÏóêÎü¨ Ï≤òÎ¶¨ Ïª®ÌÖçÏä§Ìä∏ Îß§ÎãàÏ†Ä Ìé∏Ïùò Ìï®Ïàò"""
    handler = get_error_handler()
    return handler.error_context(operation_name, **kwargs)


def error_handler_decorator(error_mappings: Dict[type, str] = None):
    """ÏóêÎü¨ Ï≤òÎ¶¨ Îç∞ÏΩîÎ†àÏù¥ÌÑ∞ Ìé∏Ïùò Ìï®Ïàò"""
    handler = get_error_handler()
    return handler.error_handler(error_mappings)


# ============================================================================
# üîÑ Streamlit ÌäπÌôî Í∏∞Îä•
# ============================================================================

def show_error_in_sidebar():
    """ÏÇ¨Ïù¥ÎìúÎ∞îÏóê ÏµúÍ∑º ÏóêÎü¨ ÌëúÏãú"""
    handler = get_error_handler()
    if handler.error_history:
        with st.sidebar:
            st.subheader("üö® ÏµúÍ∑º Ïò§Î•ò")
            recent_error = handler.error_history[-1]
            error_def = get_error_definition(recent_error['code'])
            if error_def:
                severity_config = ERROR_SEVERITY_CONFIG[error_def.severity]
                st.write(f"{severity_config['icon']} {error_def.name}")
                st.caption(f"ÏãúÍ∞Ñ: {recent_error['timestamp']}")


def show_error_statistics():
    """ÏóêÎü¨ ÌÜµÍ≥Ñ ÎåÄÏãúÎ≥¥Îìú"""
    handler = get_error_handler()
    stats = handler.get_error_statistics()
    
    if stats:
        st.subheader("üìä ÏóêÎü¨ ÌÜµÍ≥Ñ")
        
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("Ï†ÑÏ≤¥ ÏóêÎü¨", stats['total_errors'])
        with col2:
            st.metric("Ïπ¥ÌÖåÍ≥†Î¶¨", len(stats['by_category']))
        with col3:
            st.metric("Ïã¨Í∞ÅÎèÑ", len(stats['by_severity']))
        
        # Ï∞®Ìä∏ ÌëúÏãú
        if stats['most_common']:
            st.bar_chart(stats['most_common'])


# ============================================================================
# üì§ Public API
# ============================================================================

__all__ = [
    'ErrorHandler',
    'get_error_handler',
    'handle_error',
    'with_error_handling',
    'error_handler_decorator',
    'show_error_in_sidebar',
    'show_error_statistics'
]
